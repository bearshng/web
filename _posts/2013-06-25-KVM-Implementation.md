---
layout: post
title:  KVM 内存虚拟化及其实现(转)
date:   2013-6-25 12:53
categories: 虚拟化
tags: [KVM,内存虚拟化]
---


为保证客户机操作系统在虚拟环境下观察到的内存空间布局与在实际物理机环境下相同，就必须对内存进行虚拟化。对于内存虚拟化，目前主要有两种实现方法，其一是利用传统的影子页表进行虚拟化，其二就是通过硬件辅助进行实现。本文主要阐述了这两种内存虚拟化方法在 KVM 上的具体实现。

## 一、概述 ##

KVM(Kernel Virtual Machine) , 作为开源的内核虚拟机，越来越受到 IBM，Redhat，HP，Intel 等各大公司的大力支持，基于 KVM 的开源虚拟化生态系统也日益完善。而实现 KVM 虚拟化，使客户机高效地、安全地使用宿主机的内存资源，就必须实现内存的虚拟化。


 

## 二、客户机物理地址空间 ##

为了实现内存虚拟化，让客户机使用一个隔离的、从零开始且具有连续的内存空间，KVM 引入一层新的地址空间，即客户机物理地址空间 (Guest Physical Address, GPA)，这个地址空间并不是真正的物理地址空间，它只是宿主机虚拟地址空间在客户机地址空间的一个映射。对客户机来说，客户机物理地址空间都是从零开始的连续地址空间，但对于宿主机来说，客户机的物理地址空间并不一定是连续的，客户机物理地址空间有可能映射在若干个不连续的宿主机地址区间，如下图 1 所示：


<img src="/assets/img/201306/image001.gif" class ="myimage"alt="KVM 架构" title="图 1. 客户机物理地址到宿主机虚拟地址的转换" />




由于客户机物理地址不能直接用于宿主机物理 MMU 进行寻址，所以需要把客户机物理地址转换成宿主机虚拟地址 (Host Virtual Address, HVA)，为此，KVM 用一个 kvm_memory_slot 数据结构来记录每一个地址区间的映射关系，此数据结构包含了对应此映射区间的起始客户机页帧号 (Guest Frame Number, GFN)，映射的内存页数目以及起始宿主机虚拟地址。于是 KVM 就可以实现对客户机物理地址到宿主机虚拟地址之间的转换，也即首先根据客户机物理地址找到对应的映射区间，然后根据此客户机物理地址在此映射区间的偏移量就可以得到其对应的宿主机虚拟地址。进而再通过宿主机的页表也可实现客户机物理地址到宿主机物理地址之间的转换，也即 GPA 到 HPA 的转换。

实现内存虚拟化，最主要的是实现客户机虚拟地址 (Guest Virtual Address, GVA) 到宿主机物理地址之间的转换。根据上述客户机物理地址到宿主机物理地址之间的转换以及客户机页表，即可实现客户机虚拟地址空间到客户机物理地址空间之间的映射，也即 GVA 到 HPA 的转换。显然通过这种映射方式，客户机的每次内存访问都需要 KVM 介入，并由软件进行多次地址转换，其效率是非常低的。因此，为了提高 GVA 到 HPA 转换的效率，KVM 提供了两种实现方式来进行客户机虚拟地址到宿主机物理地址之间的直接转换。其一是基于纯软件的实现方式，也即通过影子页表 (Shadow Page Table) 来实现客户虚拟地址到宿主机物理地址之间的直接转换。其二是基于硬件对虚拟化的支持，来实现两者之间的转换。下面就详细阐述两种方法在 KVM 上的具体实现。


## 三、影子页表 ##


由于宿主机 MMU 不能直接装载客户机的页表来进行内存访问，所以当客户机访问宿主机物理内存时，需要经过多次地址转换。也即首先根据客户机页表把客户机虚拟地址转传成客户机物理地址，然后再通过客户机物理地址到宿主机虚拟地址之间的映射转换成宿主机虚拟地址，最后再根据宿主机页表把宿主机虚拟地址转换成宿主机物理地址。而通过影子页表，则可以实现客户机虚拟地址到宿主机物理地址的直接转换。如下图 2 所示：

<img src="/assets/img/201306/image002.gif" class ="myimage"alt="KVM 架构" title="图 2. 客户机物理地址到宿主机虚拟地址的转换" />


影子页表简化了地址转换过程，实现了客户机虚拟地址空间到宿主机物理地址空间的直接映射。但是由于客户机中每个进程都有自己的虚拟地址空间，所以 KVM 需要为客户机中的每个进程页表都要维护一套相应的影子页表。在客户机访问内存时，真正被装入宿主机 MMU 的是客户机当前页表所对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在 TLB 和 CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。

在影子页表中，每个页表项指向的都是宿主机的物理地址。这些表项是随着客户机操作系统对客户机页表的修改而相应地建立的。客户机中的每一个页表项都有一个影子页表项与之相对应。如下图 3 所示：

<img src="/assets/img/201306/image003.gif" class ="myimage"alt="KVM 架构" title="图 3. 客户机页表和影子页表" />




为了快速检索客户机页表所对应的的影子页表，KVM 为每个客户机都维护了一个哈希表，影子页表和客户机页表通过此哈希表进行映射。对于每一个客户机来说，客户机的页目录和页表都有唯一的客户机物理地址，通过页目录 / 页表的客户机物理地址就可以在哈希链表中快速地找到对应的影子页目录 / 页表。在检索哈希表时，KVM 把客户机页目录 / 页表的客户机物理地址低 10 位作为键值进行索引，根据其键值定位到对应的链表，然后遍历此链表找到对应的影子页目录 / 页表。当然，如果不能发现对应的影子页目录 / 页表，说明 KVM 还没有为其建立，于是 KVM 就为其分配新的物理页并加入此链表，从而建立起客户机页目录 / 页表和对应的影子页目录 / 页表之间的映射。当客户机切换进程时，客户机操作系统会把待切换进程的页表基址载入 CR3，而 KVM 将会截获这一特权指令，进行新的处理，也即在哈希表中找到与此页表基址对应的影子页表基址，载入客户机 CR3，使客户机在恢复运行时 CR3 实际指向的是新切换进程对应的影子页表。

## 四、影子页表异常处理机制 ##

在通过影子页表进行寻址的过程中，有两种原因会引起影子页表的缺页异常，一种是由客户机本身所引起的缺页异常，具体来说就是客户机所访问的客户机页表项存在位 (Present Bit) 为 0，或者写一个只读的客户机物理页，再者所访问的客户机虚拟地址无效等。另一种异常是由客户机页表和影子页表不一致引起的异常。

当缺页异常发生时，KVM 首先截获该异常，然后对发生异常的客户机虚拟地址在客户机页表中所对应页表项的访问权限进行检查，并根据引起异常的错误码，确定出此异常的原因，进行相应的处理。如果该异常是由客户机本身引起的，KVM 则直接把该异常交由客户机的缺页异常处理机制来进行处理。如果该异常是由客户机页表和影子页表不一致引起的，KVM 则根据客户机页表同步影子页表。为此，KVM 要建立起相应的影子页表数据结构，填充宿主机物理地址到影子页表的页表项，还要根据客户机页表项的访问权限修改影子页表对应页表项的访问权限。

由于影子页表可被载入物理 MMU 为客户机直接寻址使用， 所以客户机的大多数内存访问都可以在没有 KVM 介入的情况下正常执行，没有额外的地址转换开销，也就大大提高了客户机运行的效率。但是影子页表的引入也意味着 KVM 需要为每个客户机的每个进程的页表都要维护一套相应的影子页表，这会带来较大内存上的额外开销，此外，客户机页表和和影子页表的同步也比较复杂。因此，Intel 的 EPT(Extent Page Table) 技术和 AMD 的 NPT(Nest Page Table) 技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现客户机虚拟地址到宿主机物理地址之间的转换。下面就以 EPT 为例分析一下 KVM 基于硬件辅助的内存虚拟化实现。


 

## 五、EPT 页表 ##

EPT 技术在原有客户机页表对客户机虚拟地址到客户机物理地址映射的基础上，又引入了 EPT 页表来实现客户机物理地址到宿主机物理地址的另一次映射，这两次地址映射都是由硬件自动完成。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。EPT 页表对地址的映射机理与客户机页表对地址的映射机理相同，下图 4 出示了一个页面大小为 4K 的映射过程：


<img src="/assets/img/201306/image004.gif" class ="myimage"alt="KVM 架构" title="图 4.EPT 页表转换" />

image004

在客户机物理地址到宿主机物理地址转换的过程中，由于缺页、写权限不足等原因也会导致客户机退出，产生 EPT 异常。对于 EPT 缺页异常，KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。对 EPT 写权限引起的异常，KVM 则通过更新相应的 EPT 页表来解决。

由此可以看出，EPT 页表相对于前述的影子页表，其实现方式大大简化。而且，由于客户机内部的缺页异常也不会致使客户机退出，因此提高了客户机运行的性能。此外，KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的额外开销。